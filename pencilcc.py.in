#! /usr/bin/env python3
# -*- coding: UTF-8 -*-
# @configure_input@

import argparse
import os
import subprocess
import shlex
import tempfile
import sys # sys.stderr
import copy
import shutil # shutil.rmtree
import collections # collections.Iterable


script = os.path.abspath(sys.argv[0])

# Interface to autoconf
prefix='''@prefix@'''
exec_prefix='''@exec_prefix@'''.replace('''${prefix}''', prefix)

with_ppcg='''@with_ppcg@'''
with_pencil_util='''@with_pencil_headers@'''
with_prl='''@with_prl@'''

abs_srcdir='''@abs_srcdir@'''
abs_builddir='''@abs_builddir@'''
includedir='''@includedir@'''.replace('''${prefix}''', prefix)
bindir='''@bindir@'''.replace('''${exec_prefix}''', exec_prefix)
libdir='''@libdir@'''.replace('''${exec_prefix}''', exec_prefix)
datarootdir='''@datarootdir@'''.replace('''${prefix}''', prefix)
datadir='''@datadir@'''.replace('''${datarootdir}''',datarootdir).replace('''${prefix}''', prefix)

PPCG_BUILDDIR='''@PPCG_BUILDDIR@'''
PPCG_SRCDIR='''@PPCG_SRCDIR@'''

PENCIL_UTIL_BUILDDIR='''@PENCIL_UTIL_BUILDDIR@'''
PENCIL_UTIL_SRCDIR='''@PENCIL_UTIL_SRCDIR@'''

PRL_BUILDDIR='''@PRL_BUILDDIR@'''
PRL_SRCDIR='''@PRL_SRCDIR@'''


# Return true if running from build directory
#   True means accompanied files are looked for in the build directory
#   False means files are searched in the prefix path
def is_build():
	return abs_builddir and (os.path.dirname(script) == os.path.abspath(abs_builddir))


class Configuration:
	props = ['config', # Informational only
		  'target',
		  'cpp_disabled',  'cpp_prog',  'cpp_flags',  'cpp_verbose',
		  'ppcg_disabled', 'ppcg_prog', 'ppcg_flags', 'ppcg_verbose',
		  'cc_disabled',   'cc_prog',   'cc_flags',   'cc_verbose',   'cc_isgnu',
		  'nvcc_disabled', 'nvcc_prog', 'nvcc_flags', 'nvcc_verbose',
		  'ld_disabled',
		                   'ccld_prog', 'ccld_flags',   'ccld_verbose',
		                   'nvccld_prog','nvccld_flags','nvccld_verbose',
		  'run_enabled',   'run_flags',
		  'opt_flags',
		  'pencil_include_dir', 'pencil_h_cppflags',
		  'ocl_utilities_cppflags', 'ocl_utilities_cflags', 
		  'prl_disabled', 'prl_include_dir', 'prl_cppflags', 'prl_lflags',
		  'common_cppflags','common_cflags','common_lflags',
		  'pencil_h',
		  'opencl_embed_kernel_code','std','pencil_ext','c_ext', 'autorpath']

	def __init__(self):
		for prop in self.props:
			setattr(self, prop, None)

	def merge(self, other):
		for prop in self.props:
			val = getattr(self, prop, None)
			if val is None:
				setattr(self, prop, getattr(other, prop))

	# Platform introspection and default values
	def system_config(self):
		self.config = 'system'
		self.target = 'prl'

		self.cpp_disabled = False
		self.cpp_prog = 'cpp'
		self.cpp_flags = []
		self.cpp_verbose = 0

		self.ppcg_disabled = False
		self.ppcg_prog = 'ppcg'
		self.ppcg_flags = []
		self.ppcg_verbose = 0

		self.cc_disabled = False
		self.cc_prog = 'cc'
		self.cc_flags = []
		self.cc_verbose = 0
		self.cc_isgnu = None

		self.nvcc_disabled = False
		self.nvcc_prog = 'nvcc'
		self.nvcc_flags = []
		self.nvcc_verbose = 0

		self.ld_disabled = False

		self.ccld_prog = 'cc'
		self.ccld_flags = []
		self.ccld_verbose = 0

		self.nvccld_prog = 'nvcc'
		self.nvccld_flags = []
		self.nvccld_verbose = 0

		self.run_enabled = False
		self.run_flags = []

		self.opt_flags = []

		self.pencil_h_cppflags = []
		self.pencil_h = 'pencil.h'
		self.pencil_include_dir = ''

		self.ocl_utilities_cflags = []
		self.ocl_utilities_cppflags = []

		self.prl_disabled = False #TODO: Search for existance of libprl_opencl in system library path
		self.prl_cppflags = []
		self.prl_lflags = ['-lprl_opencl']
		self.prl_include_dir = ''
		
		self.common_cppflags = []
		self.common_cflags = []
		self.common_lflags = []

		self.opencl_embed_kernel_code = None
		self.std = None
		self.pencil_ext = ['.pencil.c','.pencil']
		self.c_ext = ['.c', '.i']
		self.autorpath = False


	def build_config(self):
		self.config = 'build'

		if with_ppcg=='no':
			self.ppcg_disabled = True
			self.ppcg_prog = ''
			self.ppcg_verbose = 0
			self.ocl_utilities_cppflags = []
			self.ocl_utilities_cflags = []
		elif with_ppcg=='bundled' or with_ppcg=='build':
			self.ppcg_disabled = False
			self.ppcg_prog = os.path.join(PPCG_BUILDDIR,'ppcg')
			self.ocl_utilities_cppflags =  ['-I', PPCG_SRCDIR]
			self.ocl_utilities_cflags = [os.path.join(PPCG_SRCDIR,'ocl_utilities.c')]

		if with_pencil_util=='no':
			self.pencil_h_cppflags = []
			self.pencil_include_dir = ''
		elif with_pencil_util=='bundled' or with_pencil_util=='build':
			self.pencil_h_cppflags = ['-I', os.path.join(PENCIL_UTIL_SRCDIR, 'include')]
			self.pencil_include_dir = os.path.join(PENCIL_UTIL_SRCDIR, 'include')

		if with_prl=='no':
			self.prl_disabled = True
			self.prl_cppflags = []
			self.prl_lflags = []
			self.prl_include_dir = ''
		elif with_prl=='bundled' or with_prl=='build':
			self.prl_disabled = False
			self.prl_cppflags = ['-I', os.path.join(PRL_SRCDIR, 'include')]
			self.prl_lflags = ['-L', os.path.join(PRL_BUILDDIR, 'src', '.libs'), '-lprl_opencl']
			self.prl_include_dir = os.path.join(PRL_SRCDIR, 'include')

		self.common_cppflags = []
		self.common_cflags = []
		self.common_lflags = []

		self.pencil_h = os.path.join(PENCIL_UTIL_SRCDIR, 'include', 'pencil.h')


	def install_config(self):
		self.config = 'install'
		
		self.ppcg_disabled = (with_ppcg=='no')
		self.ppcg_prog = os.path.join(bindir,'ppcg')
		self.ppcg_flags = []
		self.ppcg_verbose = 0

		self.pencil_h_cppflags = []

		self.ocl_utilities_cppflags = []
		self.ocl_utilities_cflags =  [os.path.join(datadir,'ppcg','ocl_utilities.c')]

		self.prl_disabled = (with_prl=='no')
		self.prl_cppflags = []
		self.prl_lflags = ['-lprl_opencl']
		
		self.common_cppflags =  ['-I', includedir]
		self.common_cflags = []
		self.common_lflags = ['-L', libdir]

		self.pencil_h = os.path.join(includedir,'pencil.h')


def show_config(config):
	if is_build():
		print("Running from builddir")
	else:
		print("Running outside builddir")
	print("cmdline:", ' '.join([shlex.quote(s) for s in sys.argv]))
	for prop in config.props:
		val=getattr(config,prop)
		if type(val) is list:
			s=' '.join([shlex.quote(v) for v in val])
		elif type(val) is str:
			s=shlex.quote(val)
		else:
			s=str(val)
		print(prop,'=',s)


system_config = None
def get_system_config():
	global system_config
	if not system_config:
		system_config = Configuration()
		system_config.system_config()
	return system_config

build_config = None
def get_build_config():
	global build_config
	if not build_config:
		build_config = Configuration()
		build_config.build_config()
		build_config.merge(get_system_config())
	return build_config

install_config = None
def get_install_config():
	global install_config
	if not install_config:
		install_config = Configuration()
		install_config.install_config()
		install_config.merge(get_system_config())
	return install_config

default_config = None
def get_default_config():
	global default_config
	if not default_config:
		if is_build():
			default_config = copy.copy(get_build_config())
		else:
			default_config = copy.copy(get_install_config())
		default_config.merge(get_system_config())
	return default_config



### Global options

print_commands = False
print_commands_baseonly = False

config = Configuration()


def print_command(cmd, *args,cwd=None,addenv=None,appendenv=None,force=False,prefix='#$ '):
	if print_commands or force:
		shortcmd = os.path.basename(cmd) if print_commands_baseonly else shlex.quote(cmd)
		setenvs = []
		if addenv is not None:
			for envkey,envval in addenv.items():
				setenvs += [envkey + '=' + shlex.quote(envval)]
		if appendenv is not None:
			for envkey,envval in appendenv.items():
				if not envval:
					continue
				setenvs += [envkey + '=' + ':'.join(['${' + envkey + '}'] + [shlex.quote(envitem) for envitem in envval])]
		setenv=''
		for elt in setenvs:
			setenv += elt + ' '
		if cwd is None:
			print(prefix + setenv + shortcmd + ' ' + ' '.join([shlex.quote(s) for s in args]),file=sys.stderr)
		else:
			print(prefix + '(cd ' + shlex.quote(cwd) + ' && ' + setenv + shortcmd + ' ' + ' '.join([shlex.quote(s) for s in args]) + ')',file=sys.stderr)


def invoke(cmd, *args,cwd=None,addenv=None,appendenv=None,showonly=False,stdout=None,stderr=None):
	print_command(cmd, *args,cwd=cwd,addenv=addenv,appendenv=appendenv)
	env=None
	if addenv is not None or appendenv is not None:
		env = copy.copy(os.environ)
		if addenv is not None:
			env.update(addenv)
		if appendenv is not None:
			for key,val in appendenv.items():
				allval = []
				if key in env:
					allval += env.get(key)
				allval += [shlex.quote(item) for item in val]
				env[key] = ':'.join(allval)

	sys.stdout.flush()
	sys.stderr.flush()
	if not showonly:
		rtncode = subprocess.call([cmd] + list(args),cwd=cwd,env=env,stdout=stdout,stderr=stderr)
		if rtncode!=0:
			err_exit("pencilcc: Subcommand failed")


def verbosity(lvl):
	if lvl > 0:
		return ['-' + 'v' * lvl]
	return []


# Currently unused; could be used with build configuration
def invoke_libtool_cc(*cmdline):
	extra_flags = verbosity(config.cc_verbose)
	extra_flags += config.cc_flags
	extra_flags += cmdline
	invoke('libtool', '--mode=link', '--tag=CC', cc_prog, *extra_flags)


def print_versions():
	print("PENCIL driver", '''@GIT_HEAD_ID@''')
	print()

	if config.ppcg_prog is not None:
		try:
			invoke(config.ppcg_prog, '--version')
		except Exception as e:
			print('ppcg:', e)
		print()

	if config.cc_prog is not None:
		try:
			invoke(config.cc_prog, '--version')
		except Exception as e:
			print('cc:', e)
		print()


# From https://bugs.python.org/issue16399
class AppendAction(argparse.Action):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if not isinstance(self.default, collections.Iterable):
            self.default = [self.default]
        self.reset_dest = False

    def __call__(self, parser, namespace, values, option_string=None):
        if not self.reset_dest:
            setattr(namespace, self.dest, [])
            self.reset_dest = True
        getattr(namespace, self.dest).append(values)


def add_captured_cc_args(defaultcfg, parser):
	# Passed to PPCG and CC
	parser.add_argument('-D', action='append', default=[], help=argparse.SUPPRESS)
	parser.add_argument('-I', action='append', default=[], help=argparse.SUPPRESS)

	# Optimization arguments also passed to nvcc/cc of the _kernel file
	parser.add_argument('-g', nargs='?', const='', help=argparse.SUPPRESS)
	parser.add_argument('-O', nargs='?', const='', help=argparse.SUPPRESS)

	# Compatibility arguments; required so the file name argument is not interpreted as input file
	parser.add_argument('-o', metavar='OUTPUT', help=argparse.SUPPRESS)
	parser.add_argument('-x', nargs=2, help=argparse.SUPPRESS) # TODO: Implement support
	parser.add_argument('-c', action='store_true', default=False, help=argparse.SUPPRESS)
	parser.add_argument('-std', metavar='STD', help="Language dialect (c99, gnu99)")


def parsecmd(defaultcfg, is_tool):
	if sys.version_info >= (3,5,0):
		parser = argparse.ArgumentParser(description="Driver for PENCIL.  Executes pencil-optimizer, ppcg and compiler as required.", add_help=False, allow_abbrev=False)
	else:
		 # Beware of prefix matching: https://mail.python.org/pipermail/python-dev/2013-November/130601.html http://bugs.python.org/issue14910
		parser = argparse.ArgumentParser(description="Driver for PENCIL.  Executes pencil-optimizer, ppcg and compiler as required.", add_help=False)
	parser.add_argument('-h', '--help', action='store_true', help="Show this help message and exit")
	parser.add_argument('--version', action='store_true', help="Print versions of involved programs")
	parser.add_argument('--show-invocation', action='store_true', default=False, help="Print the command that invoked pencilcc")
	parser.add_argument('--show-commands', action='store_true', default=False, help="Print executed commands")
	parser.add_argument('--show-commands-baseonly', action='store_true', default=False, help="Do not print full command path")	
	parser.add_argument('--show-config', action='store_true', help="Show tools' flags and exit")
	parser.add_argument('--show-ppcg-args', choices=['PROG', 'FLAGS', 'CPPFLAGS', 'DEFS', 'DEFFLAGS', 'INCLUDE_DIRS'], help="Show the flags passed to ppcg and exit")
	parser.add_argument('--show-cc-args',   choices=['PROG', 'FLAGS', 'CPPFLAGS', 'DEFS', 'DEFFLAGS', 'INCLUDE_DIRS', 'LIBS', 'LIBRARY_DIRS'], help="Show the flags passed to cc and exit")
	parser.add_argument('--show-run-args', choices=['LD_LIBRARY_PATH'], help="Show the effective variable and exit")
	parser.add_argument('--show-listsep', default=' ')

	parser.add_argument('-v', '--verbose', action='count', default=0, help="More verbose output")
	parser.add_argument('--pencil-config', choices=['system', 'build', 'install'], help="Introspection to use")

	parser.add_argument('--keep', '-save-temps', action='store_true', help="Keep temporary files next to files to compile")
	parser.add_argument('--keep-dir', help="Directory for temporary files")
	parser.add_argument('--pencil-tmpdir', help="Directory to use for temporary files")

	parser.add_argument('--cpp',dest='cpp',action='store_true')
	parser.add_argument('--no-cpp',dest='cpp',action='store_false')
	parser.add_argument('--cpp-prog',metavar='CPP',default=None,help="Path to preprocessor executable (default: " + defaultcfg.cpp_prog + ")")
	parser.add_argument('--cpp-arg', '-Xpreprocessor',action='append',help="Additional argument for preprocessor (passed literally)")
	parser.add_argument('--cpp-args',action='append',help="Additional arguments for preprocessor (will be unescaped")

	parser.add_argument('--ppcg',dest='ppcg',action='store_true')
	parser.add_argument('--no-ppcg',dest='ppcg',action='store_false')
	parser.add_argument('--ppcg-prog',metavar='PPCG',default=None,help="Path to ppcg executable (default: " + defaultcfg.ppcg_prog + ")")
	parser.add_argument('--ppcg-arg', '-Xppcg',action='append',help="Additional argument for ppcg (passed literally)")
	parser.add_argument('--ppcg-args',action='append',help="Additional arguments for ppcg (will be unescaped")

	if not is_tool:
		parser.add_argument('--tool-prog',help="Path to C compiler executable (default: " + (defaultcfg.cc_prog if defaultcfg.cc_prog is not None else defaultcfg.c99_prog) + ")")
		parser.add_argument('--tool-arg', action='append',help="Additional compiler argument (passed literally)") # How to pass -Xcompiler when linking?
		parser.add_argument('--tool-args',action='append',help="Additional compiler arguments (will be unescaped)")

	parser.add_argument('--cc',dest='cc',action='store_true')
	parser.add_argument('--no-cc',dest='cc',action='store_false')
	parser.add_argument('--cc-prog', metavar='CC', help="Path to C compiler executable (default: " + (defaultcfg.cc_prog if defaultcfg.cc_prog is not None else defaultcfg.c99_prog) + ")")
	parser.add_argument('--cc-arg', action='append',help="Additional compiler argument (passed literally)") # How to pass -Xcompiler when linking?
	parser.add_argument('--cc-args',action='append',help="Additional compiler arguments (will be unescaped)")


	# Used for compiling .cu files (ppcg output), linking (--target=cuda)
	# Is disabled by --no-cc as well
	parser.add_argument('--nvcc-prog',metavar='NVCC', help="Path to nvcc compiler executable (default: " + defaultcfg.nvcc_prog + ")")
	parser.add_argument('--nvcc-arg', action='append',help="Additional nvcc argument (passed literally)")
	parser.add_argument('--nvcc-args', action='append',help="Additional nvcc arguments (will be unescaped)")

	# Used for lingking (and compiling non-pencil files) with --target=cuda
	parser.add_argument('--nvcc-ld-prog', metavar='NVCCLD')
	parser.add_argument('--nvcc-ld-arg', action='append')
	parser.add_argument('--nvcc-ld-args', action='append')

	# Usid for  lingking (and compiling non-pencil files) with --target=prl/opencl
	parser.add_argument('--cc-ld-prog', metavar='CCLD')
	parser.add_argument('--cc-ld-arg', action='append')
	parser.add_argument('--cc-ld-args', action='append')

	parser.add_argument('--autorpath', action='store_true', help="Set linker rpath to runtime libraries.")
	parser.add_argument('--pencil-ext', metavar='SUFFIXES', action=AppendAction, default=defaultcfg.pencil_ext,
		help="File extentions for forcing --pet-autodetect (default: .pencil.c,.pencil)")
	parser.add_argument('--c-ext', metavar='SUFFIXES', action=AppendAction, default=defaultcfg.c_ext,
		help="File extensions that are to be processed by ppcg (implicitely includes all --pencil-ext)")

	# Action control
	parser.add_argument('--noselfupdate', dest='selfupdate', action='store_false', default=True,
		help="Do not try to update yourself" if is_build() else argparse.SUPPRESS)

	parser.add_argument('--run',    dest='run', action='store_true', help="Run executable after compilation")
	parser.add_argument('--no-run', dest='run', action='store_false', help="Do not run executable after linking (default)")
	parser.add_argument('--run-arg','-Xrun', action='append', help="Arguments passed to executable (passed literally)")
	parser.add_argument('--run-args', action='append', help="Arguments passed to executable (will be unescaped)")
	parser.set_defaults(ppcg=None,cpp=None,cc=None,nvcc=None,run=None)

	# Passed to PPCG only
	parser.add_argument('--target', choices=['prl', 'opencl', 'cuda'], default='prl', help="Generate code for (default: prl)")
	if not is_tool:
		parser.add_argument('--opencl-include-file', metavar='HEADER', action='append', default=[], help=argparse.SUPPRESS)
		parser.add_argument('--no-isl-schedule-separate-components', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--isl-schedule-max-coefficient', metavar='CEOFF', help=argparse.SUPPRESS)
		parser.add_argument('--no-shared-memory', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--no-private-memory', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--sizes', metavar='SIZES', help=argparse.SUPPRESS)
		parser.add_argument('--dump-sizes', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--no-opencl-print-kernel-types', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--no-schedule-whole-component', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--schedule-maximize-coincidence', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--pet-autodetect', action='store_true', help=argparse.SUPPRESS)
		parser.add_argument('--opencl-embed-kernel-code', action='store_false', dest='opencl_embed_kernel_code',  help=argparse.SUPPRESS)
		parser.add_argument('--no-opencl-embed-kernel-code', action='store_true', dest='opencl_embed_kernel_code', help=argparse.SUPPRESS)

	if is_tool:
		parser.add_argument('tool', metavar='TOOL')
		parser.add_argument('unknown', nargs=argparse.REMAINDER)
	else:
		add_captured_cc_args(defaultcfg, parser)


	known, unknown = parser.parse_known_args()
	if is_tool:
		# Parse the tool's arguments
		if sys.version_info >= (3,5,0):
			parser = argparse.ArgumentParser(prog=known.tool, add_help=False, allow_abbrev=False)
		else:
			parser = argparse.ArgumentParser(prog=known.tool, add_help=False)
		add_captured_cc_args(defaultcfg, parser)
		tool_known, tool_unkown = parser.parse_known_args(known.unknown)
		known.cc_prog = known.tool
		known.D = tool_known.D
		known.I = tool_known.I
		known.std = tool_known.std
		known.o = tool_known.o
		known.unknown = tool_unkown
		known.ppcg_args = unknown

		# Just dummy properties, they are parsed as 'unknown'
		known.opencl_include_file = []
		known.no_isl_schedule_separate_components = None
		known.isl_schedule_max_coefficient = None
		known.no_shared_memory = None
		known.no_private_memory = None
		known.sizes = None
		known.dump_sizes = None
		known.no_opencl_print_kernel_types = None
		known.no_schedule_whole_component = None
		known.schedule_maximize_coincidence = None
		known.pet_autodetect = None
	else:
		known.unknown = unknown

	return known, parser


def error_exit(msg):
	print(msg, file=sys.stderr)
	exit(4)


def get_config_from_argparse(known):
	config = Configuration()

	if known.verbose is not None:
		config.cpp_verbose = max(0, known.verbose - 1)
		config.ppcg_verbose = max(0, known.verbose - 1)
		config.cc_verbose = max(0, known.verbose - 1)
		config.nvcc_verbose = max(0, known.verbose - 1)
		config.ccld_verbose = max(0, known.verbose - 1)
		config.nvccld_verbose = max(0, known.verbose - 1)

	if known.cpp is not None:
		config.cpp_disabled = not known.cpp
	if known.cpp_prog is not None:
		config.cpp_prog = known.cpp_prog

	if known.ppcg is not None:
		config.ppcg_disabled = not known.ppcg
	if known.ppcg_prog is not None:
		config.ppcg_prog = known.ppcg_prog

	if known.tool_prog is not None:
		config.cpp_prog = known.tool_prog
		config.cc_prog = known.tool_prog
		config.nvcc_proc = known.tool_prog
		config.ccld_prog = known.tool_prog
		config.nvccld_prog = known.tool_prog

	if known.cc is not None:
		config.cc_disabled = not known.cc
	if known.cc_prog is not None:
		config.cc_prog = known.cc_prog
	config.cc_isgnu = None # Unknown; will test later

	if known.nvcc_prog is not None:
	   config.nvcc_prof = known.nvcc_prog

	if known.cc_ld_prog is not None:
		config.ccld_prog = known.cc_ld_prog

	if known.nvcc_ld_prog is not None:
		config.nvccld_prog = known.nvcc_ld_prog

	if known.run is not None:
		config.run_enabled = known.run

	if known.target == 'opencl':
		config.target = 'opencl'
		config.prl_disabled = True
	elif known.target == 'cuda':
		config.target='cuda'
		config.prl_disabled = True
	else:
		config.target = 'prl'
		config.prl_disabled = False

	if known.c is not None:
		config.ld_disabled = known.c
	if known.autorpath is not None:
		config.autorpath = known.autorpath

	if known.pencil_ext is not None:
		config.pencil_ext = known.pencil_ext
	if known.c_ext is not None:
		config.c_ext = known.c_ext

	config.cpp_flags = []
	config.ppcg_flags = []
	config.cc_flags = []
	config.nvcc_flags = []
	config.opt_flags = []
	config.ccld_flags = []
	config.nvccld_flags = []

	for incfile in known.opencl_include_file:
		config.ppcg_flags += ['--opencl-include-file=' + incfile]
	if known.no_isl_schedule_separate_components:
		config.ppcg_flags += ['--no-isl-schedule-separate-components']
	if not known.isl_schedule_max_coefficient is None:
		config.ppcg_flags += ['--isl-schedule-max-coefficient=' + known.isl_schedule_max_coefficient]
	if known.no_shared_memory:
		config.ppcg_flags += ['--no-shared-memory']
	if known.no_private_memory:
		config.ppcg_flags += ['--no-private-memory']
	if known.sizes is not None:
		config.ppcg_flags += ['--sizes=' + known.sizes]
	if known.dump_sizes:
		config.ppcg_flags += ['--dump-sizes']
	if known.no_opencl_print_kernel_types:
		config.ppcg_flags += ['--no-opencl-print-kernel-types']
	if known.no_schedule_whole_component:
		config.ppcg_flags += ['--no-schedule-whole-component']
	if known.schedule_maximize_coincidence:
		config.ppcg_flags += ['--schedule-maximize-coincidence']
	if known.opencl_embed_kernel_code is not None:
		config.opencl_embed_kernel_code = known.opencl_embed_kernel_code

	for flag in known.D:
		config.cpp_flags += ['-D' + flag]
	for i in known.I:
		config.cpp_flags += ['-I', i]
	if known.O is not None:
		config.opt_flags += ['-O' + known.O]
	if known.g is not None:
		config.opt_flags += ['-g' + known.g]

	if known.std is not None:
		config.std = known.std

	if known.cpp_args is not None:
		config.cpp_flags += [s for args in known.cpp_args for s in shlex.split(args)]
	if known.cpp_arg is not None:
		config.cpp_flags += known.cpp_arg

	if known.ppcg_args is not None:
		config.ppcg_flags += [s for args in known.ppcg_args for s in shlex.split(args)]
	if known.ppcg_arg is not None:
		config.ppcg_flags += known.ppcg_arg

	if known.cc_args is not None:
		config.cc_flags += [s for args in known.cc_args for s in shlex.split(args)]
	if known.cc_arg is not None:
		config.cc_flags += known.cc_arg

	if known.nvcc_args is not None:
		config.nvcc_flags += [s for args in known.nvcc_args for s in shlex.split(args)]
	if known.nvcc_arg is not None:
		config.nvcc_flags += known.nvcc_arg

	if known.cc_ld_args is not None:
		config.ccld_flags += [s for args in known.cc_ld_args for s in shlex.split(args)]
	if known.cc_ld_arg is not None:
		config.ccld_flags += known.ccld_arg

	if known.nvcc_ld_args is not None:
		config.nvccld_flags += [s for args in known.nvcc_ld_args for s in shlex.split(args)]
	if known.nvcc_ld_arg is not None:
		config.nvccld_flags += known.nvccld_arg

	tool_flags = []
	if known.tool_args is not None:
		tool_flags += [s for args in known.tool_args for s in shlex.split(args)]
	if known.tool_arg is not None:
		tool_flags += known.tool_arg
	config.cpp_flags += tool_flags
	config.cc_flags += tool_flags
	config.nvcc_flags += tool_flags
	config.ccld_flags += tool_flags
	config.nvccld_flags += tool_flags

	if known.run_args is not None:
		config.run_flags += [s for args in known.run_args for s in shlex.split(args)]
	if known.run_arg is not None:
		config.run_flags += known.run_arg

	return config


def parse_cc_arguments(args):
	if sys.version_info >= (3,5,0):
		flagsparser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)
	else:
		flagsparser = argparse.ArgumentParser(add_help=False)
	flagsparser.add_argument('-L', action='append', default=[])
	flagsparser.add_argument('-l', action='append', default=[])
	flagsparser.add_argument('-D', action='append', default=[])
	flagsparser.add_argument('-I', action='append', default=[])
	return flagsparser.parse_known_args([''] + args)


def extract_library_paths(args):
	lflags, other = parse_cc_arguments(args)
	libpaths = set()
	for L in lflags.L:
		libpaths.add(L)
	for l in lflags.l:
		path,_ = os.path.split(l)
		if not path:
			continue
		path = os.path.dirname(path)
		libpaths.add(path)
	return libpaths


def changeext(filename,newext):
	rootname,oldext = os.path.splitext(filename)
	return rootname + newext


def common_cpp_args(pencil_level,isc,ispencil):
	global config
	cppflags = []

	if isc or ispencil:
		if pencil_level is not None:
			cppflags += ['-D__PENCIL__=' + str(pencil_level)]

		if config.target == 'cuda':
			cppflags += ['-D__PENCIL_CUDA__']
		else:
			cppflags += ['-D__PENCIL_OPENCL__']
		if config.target=='prl':
			cppflags += ['-D__PENCIL_PRL__']

	if ispencil:
		cppflags += ['-D__PENCIL_PURE__']

	cppflags += config.common_cppflags
	cppflags += config.pencil_h_cppflags

	if config.target=='cuda':
		pass
	elif config.prl_disabled:
		if isc or ispencil:
			cppflags += config.ocl_utilities_cppflags
	else:
		# Allow host part (eg. written in C++) to call PRL functions as well
		cppflags += config.prl_cppflags

	cppflags += config.cpp_flags

	return cppflags


def common_cc_args(args, isc, ispencil):
	global config
	ccflags = []

	ccflags += common_cpp_args(pencil_level=3 if isc or ispencil else None,isc=isc, ispencil=ispencil)
	ccflags += config.common_cflags
	ccflags += config.cc_flags

	if isc or ispencil:
		if  config.cc_isgnu:
			ccflags += ['-Wno-attributes']                    # __attribute__((pencil_access)) not removed by ppcg
			ccflags += ['-Wno-implicit-function-declaration'] # __pencil_use/def/maybe left in summary functions

	for arg in args:
		if arg.is_arg():
			ccflags += [arg.args]

	ccflags += config.opt_flags

	return ccflags


# These are flags for the compiler driver which passes flags to the linker
def common_ld_args():
	global config
	ldflags = []

	if config.target != 'cuda':
		ldflags += config.common_lflags
		if config.prl_disabled :
			ldflags += config.ocl_utilities_cflags
		else:
			ldflags += config.prl_lflags
		ldflags += ['-lOpenCL', '-lm']

	if config.autorpath:
		libpaths = extract_library_paths(ldflags)
		for libpath in libpaths:
			ldflags += ['-Xlinker', '-rpath', '-Xlinker', libpath] # -Wl is not recognized by nvcc

	return ldflags



def get_std_arg(isc, ispencil):
	global config

	if not config.cc_isgnu:
		return []

	if isc or ispencil:
		# Use the user-specified C-dialect, gnu99 is default
		std = 'gnu99'
		if config.std in {'c89', 'c90', 'c99', 'c9x', 'iso9899:1990', 'iso9899:199409', 'c11', 'c1x', 'iso9899:2011', 'gnu98', 'gnu90', 'gnu9x', 'gnu99', 'gnu11', 'gnu1x'}:
			std = config.std
		return ['-std=' + std]
	else:
		# Use the user-specified one, even if C++
		if config.std is None:
			return []
		else:
			return ['-std=' + config.std]


def assemble_cpp_args(infile, outfile, isc, ispencil, args):
	global config

	cppargs = ['-E']
	cppargs += verbosity(config.cpp_verbose)
	if infile is not None:
		cppargs += ['-x', 'c', infile]
	cppargs += get_std_arg(isc, ispencil)

	cppargs += common_cpp_args(pencil_level=1,isc=isc,ispencil=ispencil)
	cppargs += ['-D__PENCIL_CPP__']
	cppargs += config.cpp_flags
	for arg in args:
		if arg.is_arg():
			cppargs += [arg.arg]

	if outfile is not None:
		cppargs += ['-o', outfile]
	return cppargs


def exec_cpp(infile, outfile, isc, ispencil, args):
	global config
	if outfile is None:
		outfile = changeext(infile, '.i')
	cppargs = assemble_cpp_args(infile=infile,outfile=outfile,isc=isc,ispencil=ispencil,args=args)
	invoke(config.cc_prog, *cppargs)


def assemble_ppcg_args(infile, outfile, isc, ispencil, force_embed):
	global config

	ppcgargs = []
	ppcgargs += verbosity(config.ppcg_verbose)
	if infile is not None:
		ppcgargs += [infile]

	ppcgargs += common_cpp_args(pencil_level=2, isc=isc, ispencil=ispencil)
	ppcgargs += ['-D__PENCIL_PPCG__']

	ppcgargs += ['--target=' + config.target]
	if ispencil:
		ppcgargs += ['--pet-autodetect']
	if (config.target != 'cuda') and (config.opencl_embed_kernel_code or force_embed):
		ppcgargs += ['--opencl-embed-kernel-code']

	if isc or ispencil:
		ppcgargs += ['--pet-include=' + os.path.join(config.pencil_include_dir, 'pencil_ppcg.h')]
		ppcgargs += ['--host-include-file=' + os.path.join(config.pencil_include_dir,'pencil_host_c.h')]
		if config.target != 'cuda':
			ppcgargs += ['--kernel-include-file=' + os.path.join(config.pencil_include_dir, 'pencil_kernel_c.h')]
			ppcgargs += ['--opencl-include-file=' + os.path.join(config.pencil_include_dir, 'pencil_kernel_cl.h')]
			if config.target == 'prl':
				ppcgargs += ['--kernel-include-file=' + os.path.join(config.prl_include_dir, 'prl_scop.h')]
		else:
			ppcgargs += ['--kernel-include-file=' + os.path.join(config.pencil_include_dir, 'pencil_kernel_cu.h')]
	ppcgargs += config.ppcg_flags

	if outfile is not None:
		ppcgargs += ['-o', outfile]
	return ppcgargs


def exec_ppcg(infile, outfile, isc, ispencil, force_embed):
	global config
	ppcgargs = assemble_ppcg_args(infile=infile, outfile=outfile, isc=isc, ispencil=ispencil,force_embed=force_embed)
	invoke(config.ppcg_prog, *ppcgargs)


# To compile _host.c and .pencil.c (with --no-ppcg)
def assemble_cc_args(infile, outfile, args, isc, ispencil, moreargs, ishostc=False, iskernelc=False):
	global config

	ccargs = ['-c']
	ccargs += verbosity(config.cc_verbose)
	if infile is not None:
		if ishostc or iskernelc:
			ccargs += ['-x', 'c', infile]
		else:
			ccargs += [infile]

	ccargs += get_std_arg(isc, ispencil)
	ccargs += common_cc_args(args=args, isc=isc, ispencil=ispencil)
	if moreargs is not None:
		ccargs += moreargs

	if outfile is not None:
		ccargs += ['-o', outfile]
	return ccargs


def exec_cc(infile, outfile,args, isc, ispencil, moreargs, ishostc=False, iskernelc=False):
	global config
	ccargs = assemble_cc_args(infile=infile, outfile=outfile, args=args, isc=isc, ispencil=ispencil, moreargs=moreargs, ishostc=ishostc, iskernelc=iskernelc)
	invoke(config.cc_prog, *ccargs)


# For compiling _kernel.cu
# nvcc calls gcc to call ld
def assemble_nvcc_cc_args(infile, outfile,args):
	global config

	nvccargs = ['--compile']
	nvccargs += verbosity(config.nvcc_verbose)
	if infile is not None:
		nvccargs += [infile]

	ccargs = common_cc_args(args=args,isc=False,ispencil=False)
	compatible,incompatible = filter_nvcc_args(ccargs)
	nvccargs += compatible
	for flag in incompatible:
		nvccargs += ['-Xcompiler', flag]
	nvccargs += config.nvcc_flags
	nvccargs += ['-D__PENCIL_KERNEL__']

	if outfile is not None:
		nvccargs += ['-o', outfile]
	return nvccargs

def exec_nvcc_cc(infile,outfile,args):
	global config
	nvccargs = assemble_nvcc_cc_args(args=args,infile=infile,outfile=outfile)
	invoke(config.nvcc_prog, *nvccargs)


# To combine all previous artifacts, ie. object files (.o), non-pencil sources (.cpp, etc), non-existing files
def assemble_cc_ld_args(args, outfile):
	global config

	ldargs = []
	ldargs += verbosity(config.ccld_verbose)

	ldargs += get_std_arg(isc=False, ispencil=False)
	ldargs += common_cc_args(args=[],isc=False,ispencil=False)

	if args is not None:
		for arg in args:
			if arg.is_arg():
				ldargs += [arg.arg]
			else:
				ldargs += arg.latest_objects()

	ldargs += common_ld_args()
	ldargs += config.ccld_flags

	if outfile is not None:
		ldargs += ['-o', outfile]
	return ldargs

def exec_cc_ld(args,outfile,moreargs):
	global config
	ldargs = assemble_cc_ld_args(args=args, outfile=outfile)
	if moreargs is not None:
		ldargs += moreargs
	invoke(config.ccld_prog, *ldargs)


def assemble_nvcc_ld_args(args, outfile):
	global config

	nvccargs = []
	nvccargs += verbosity(config.nvccld_verbose)

	std = get_std_arg(isc=False, ispencil=False)
	if std:
		nvccargs += ['-Xcompiler'] + std

	ccargs = common_cc_args(args=[],isc=False,ispencil=False)
	compatible,incompatible = filter_nvcc_args(ccargs)
	nvccargs += compatible
	for flag in incompatible:
		nvccargs += ['-Xcompiler', flag]

	if args is not None:
		toolargs = []
		for arg in args:
			if arg.is_arg():
				toolargs += [arg.arg]
			else:
				toolargs += arg.latest_objects()
		nvccargs += toolargs

	ldargs = common_ld_args()
	nvccargs += ldargs	# FIXME: There seems to be a way to pass arguments to gcc when linking

	nvccargs += config.nvccld_flags

	if outfile is not None:
		nvccargs += ['-o', outfile]
	return nvccargs

def exec_nvcc_ld(args,outfile):
	global config
	nvccargs = assemble_nvcc_ld_args(args=args,outfile=outfile)
	invoke(config.nvccld_prog, *nvccargs)


def cpp_file(filearg, outfile,args):
	global config
	if config.cpp_disabled:
		return

	exec_cpp(infile=filearg.input_file, outfile=outfile, isc=filearg.isc, ispencil=filearg. ispencil, args=args)

	if outfile is None:
		outfile = changeext(outfile,'.i')
	filearg.cpp_i = outfile


def ppcg_file(filearg, outfile, force_embed):
	global config
	if config.ppcg_disabled:
		return

	infile = filearg.latest_host_source()
	exec_ppcg(infile=infile, outfile=outfile,isc=filearg.isc, ispencil=filearg.ispencil, force_embed=force_embed)

	if outfile is None:
		rootname,ext = os.path.splitext(infile)
		filearg.ppcg_host_c = os.path.abspath(rootname + '_host.c')
	else:
		rootname,ext = os.path.splitext(outfile)
		filearg.ppcg_host_c = outfile

	# ppcg indeed writes all files (except the .c specified by -o) extinto the current directory
	if config.target == 'cuda':
		filearg.ppcg_kernel_cu = os.path.abspath(rootname + '_kernel.cu')
		filearg.ppcg_kernel_hu = os.path.abspath(rootname + '_kernel.hu')
	else:
		filearg.ppcg_kernel_h = os.path.abspath(rootname + '_kernel.h')
		filearg.ppcg_kernel_c = os.path.abspath(rootname + '_kernel.c')
		filearg.ppcg_kernel_cl = os.path.abspath(rootname + '_kernel.cl')


def cc_file(infile, outfile,args, isc, ispencil, moreargs, ishostc=False, iskernelc=False):
	global config
	if config.cc_disabled:
		return None

	exec_cc(infile=infile,outfile=outfile,args=args,isc=isc,ispencil=ispencil,moreargs=moreargs,ishostc=ishostc,iskernelc=iskernelc)

	if outfile is None:
		outfile = changeext(infile, '.o')
	return outfile


def nvcc_cc_file(filearg, outfile,args):
	global config
	if config.cc_disabled:
		return

	exec_nvcc_cc(args=args,infile=filearg.ppcg_kernel_cu, outfile=outfile)

	if outfile is None:
		filearg.nvcc_kernel_o = os.path.abspath(rootname + '.o')
	else:
		filearg.nvcc_kernel_o = outfile


def cc_ld_file(args,outfile):
	global config
	if config.ld_disabled:
		return

	exec_cc_ld(args=args,outfile=outfile,moreargs=[])

	if outfile is None:
		outfile = 'a.out'
	return outfile


def nvcc_ld_file(args,outfile):
	global config
	if config.ld_disabled:
		return

	exec_nvcc_ld(args, outfile)

	if outfile is None:
		outfile = 'a.out'
	return outfile


def filter_nvcc_args(ldargs):
	i=0
	known = []
	unknown = []

	# Cannot use argparse because order of -l and file parameters matter
	while i < len(ldargs):
		ldarg = ldargs[i]
		if ldarg.startswith('-l') or ldarg.startswith('-L') or ldarg.startswith('-D') or ldarg.startswith('-I') or ldarg.startswith('-o') or ldarg.startswith('-O'):
			if len(ldarg)==2:
				known += [ldarg, ldargs[i+1]]
				i+=2
			else:
				known += [ldarg]
				i+=1
			continue
		if ldarg.startswith('-g'):
			known += [ldarg]
			i+=1
			continue
		elif ldarg == '-Xlinker':
			known += [ldarg, ldargs[i+1]]
			i+=2
			continue
		elif ldarg.startswith('-'):
			unknown += [ldarg]
			i+=1
			continue

		# File parameter
		known.append(ldarg)
		i+=1

	return known,unknown


def ld_relocate_file(filearg,outfile):
	global config
	objects = filearg.latest_objects()

	if config.target=='cuda' and False: # This doesn't work becaure nvcc ignored --cudart=none
		cc = config.nvcc_prog
		args = []
		args += verbosity(config.nvcc_verbose)
		args += objects
		args += ['-Xlinker','--relocatable', '-Xcompiler','-nostartfiles', '-Xcompiler','-nodefaultlibs', '-Xcompiler','-nostdlib','--cudart=none', '-o', outfile]
		invoke(cc, *args)
	else:
		cc = config.cc_prog
		args = []
		args += verbosity(config.cc_verbose)
		args += objects
		args += ['-Xlinker','--relocatable', '-nostartfiles','-nodefaultlibs','-nostdlib', '-o', outfile]
		invoke(cc, *args)
	filearg.ld_o = outfile


def ld_file(args, outfile):
	# ld cannot depend on has_extc, has_pencil, has_cuda because the build tool may have invoked -c before
	global config

	if config.target=='cuda':
		return nvcc_ld_file(args,outfile)
	else:
		return cc_ld_file(args,outfile)


def launch(prog):
	global config

	if config.autorpath:
		invoke(prog, *config.run_flags)
	else:
		ldargs = common_ld_args()
		ldlibrary = extract_library_paths(ldargs)
		invoke(prog, *config.run_flags, appendenv={'LD_LIBRARY_PATH': ldlibrary})


def is_gnu(cc, tmpdir):
	ccfilename = os.path.join(tmpdir,'checkgnu.c')
	with open(ccfilename, "w") as ccfile:
		ccfile.write("""
int main() {
#ifdef __GNUC__
	return 0;
#else
	This is not gcc!
#endif
}
			""")
	try:
		invoke(cc, '-std=c99', '-Wno-attributes', ccfilename, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
	except:
		return False
	return True


def err_exit(msg):
	print(msg, file=sys.stderr)
	exit(4)


class CCArg:
	arg = None

	input_file = None
	isc = False
	ispencil = False

	cpp_i = None

	ppcg_host_c = None
	ppcg_kernel_h = None
	ppcg_kernel_c = None
	ppcg_kernel_cl = None
	ppcg_kernel_hu = None
	ppcg_kernel_cu = None

	cc_host_o = None
	cc_kernel_o = None
	nvcc_kernel_o = None

	ld_o = None
	ld_exe = None


	def __init__(self, arg, is_input):
		global config

		if is_input:
			self.input_file = arg
			self.ispencil = has_ext(arg, config.pencil_ext)
			self.isc = not self.ispencil and has_ext(arg, config.c_ext)
		else:
			self.arg = arg


	def is_arg(self):
		return self.arg is not None


	def latest_host_source(self):
		if self.ppcg_host_c is not None:
			return self.ppcg_host_c
		if self.cpp_i is not None:
			return self.cpp_i
		if (self.isc or self.ispencil) and self.input_file is not None:
			return self.input_file


	def latest_objects(self):
		if self.ld_o is not None:
			return [self.ld_o]

		objects = []

		if self.cc_host_o is not None:
			objects += [self.cc_host_o]
		elif self.ppcg_host_c is not None:
			objects += [self.ppcg_host_c]

		if self.cc_kernel_o is not None:
			objects += [self.cc_kernel_o]
		elif self.ppcg_kernel_c is not None:
			objects += [self.ppcg_kernel_c]

		if self.nvcc_kernel_o is not None:
			objects += [self.nvcc_kernel_o]
		elif self.ppcg_kernel_cu is not None:
			objects += [self.ppcg_kernel_cu]

		if not objects:
			if self.cpp_i is not None:
				objects += [self.cpp_i]
			elif self.input_file is not None:
				objects += [self.input_file]

		return objects


def print_list(list,listsep,shellargs):
	print(listsep.join([shlex.quote(s) for s in list]))


def show_args(what, listsep, prog, args):
	if what=='PROG':
		print(prog)
		return
	if what=='FLAGS':
		print_list(args, listsep, True)
		return
	if what=='LD_LIBRARY_PATH':
		print_list(extract_library_paths(args), listsep, False)
		return
	args, other = parse_cc_arguments(args)
	if what=='CPPFLAGS':
		print_list(['-I' + I for I in args.I] + ['-D' + D for D in args.D], listsep, True)
	elif what=='DEFS':
		print_list(args.D, listsep, False)
	elif what=='DEFFLAGS':
		print_list(['-D' + D for D in args.D], listsep, True)
	elif what=='INCLUDE_DIRS':
		print_list(args.I, listsep, False)
	elif what=='LIBS':
		print_list(args.l, listsep, False)
	elif what=='LIBRARY_DIRS':
		print_list(args.L, listsep, False)


def process(is_tool):
	known, parser = parsecmd(get_system_config(), is_tool)
	
	# Do early because the selfupdate feature reads it
	global print_commands,print_commands_baseonly
	print_commands = (known.verbose > 0) or known.show_commands or known.show_commands_baseonly
	print_commands_baseonly = known.show_commands_baseonly

	if known.show_invocation:
		print_command(*sys.argv,force=True)

	# Re-configure the script automatically if in builddir
	if known.selfupdate and is_build():
		invoke('make', os.path.basename(script),cwd=os.path.dirname(script),stdout=subprocess.DEVNULL,stderr=subprocess.DEVNULL)
		cmdline=[sys.argv[0], '--noselfupdate'] + sys.argv[1:]
		cmdline = [x for x in cmdline if x !=  '--show-invocation'] # Do not show invocation a second time
		invoke(*cmdline)
		return

	global config
	config = get_config_from_argparse(known)
	if known.pencil_config=='system':
		config.merge(get_system_config())
	elif known.pencil_config=='build':
		config.merge(get_build_config())
	elif known.pencil_config=='install':
		config.merge(get_install_config())
	else:
		config.merge(get_default_config())

	if known.help:
		known, parser = parsecmd(config, is_tool) # To use correct defaults
		parser.print_help()
		return 

	if known.version:
		print_versions()
		return

	file_args = []
	n_files = 0
	prev_is_l = False
	for arg in known.unknown:
		if prev_is_l:
			file_args += [CCArg(arg, False)]
			prev_is_l = False
		elif arg=='-l':
			file_args += [CCArg(arg, False)]
			prev_is_l = True
		elif arg.startswith('-'):
			file_args += [CCArg(arg, False)]
		else:
			file_args += [CCArg(arg, True)]
			n_files += 1

	with tempfile.TemporaryDirectory(prefix='pencil.') as tmpdir:
		if config.cc_isgnu is None:
			config.cc_isgnu = is_gnu(config.cc_prog, tmpdir)

		if known.show_ppcg_args is not None:
			show_args(known.show_ppcg_args, known.show_listsep, config.ppcg_prog, assemble_ppcg_args(None, None, None, None))
			return
		if known.show_cc_args is not None:
			show_args(known.show_cc_args, known.show_listsep, config.cc_prog, assemble_cc_args([arg for arg in file_args if arg.is_arg()], None, [], None, None))
			return
		if known.show_run_args is not None:
			show_args(known.show_run_args, known.show_listsep, config.cc_prog, assemble_cc_args([arg for arg in file_args if arg.is_arg()], None, [], None, None))
			return
		if known.show_config:
			show_config(config)
			return

		if config.autorpath and not config.cc_isgnu:
			print("WARNING: --autorpath required GNU binutils",file=sys.stderr)
		if config.ld_disabled and not config.cc_disabled and not config.cc_isgnu:
			print("WARNING: --relocatable required GNU binutils",file=sys.stderr)

		if n_files<=0:
			err_exit("No input files")

		if config.ppcg_disabled and config.cc_disabled and config.ld_disabled and not config.run_enabled:
			print("Toolchain is empty; nothing to do")
			exit(0)
		elif not config.ppcg_disabled and config.cc_disabled and not config.ld_disabled:
			err_exit("Cannot link generated source without compiling it")
		elif config.run_enabled and config.ld_disabled:
			err_exit("Cannot run program without linking")
		elif not config.ppcg_disabled and config.cc_disabled and (n_files!=1) and known.o is not None:
			err_exit("Can just take one input file")

		if known.keep:
			compile(file_args, known.keep_dir, known.o, False)
		elif known.pencil_tmpdir:
			tmpdir = known.pencil_tmpdir
			if os.path.isdir(tmpdir):
				# Do not delete directories we did not create
				compile(file_args, tmpdir, known.o, True)
			else:
				os.makedirs(tmpdir)
				compile(file_args, tmpdir, known.o, True)
				if not known.keep_dir:
					shutil.rmtree(tmpdir)
		else:
			compile(file_args, tmpdir, known.o, True)


def has_ext(filename, suffixes):
	for suffix in suffixes:
		if filename.endswith(suffix):
			return True
	return False


def mktempwd(islast, outfile, tmpdir, prefix, targetfilename, use_subdir):
	if islast:
		return outfile

	if tmpdir is None:
		# with --keep and without --keep-dir
		return targetfilename
	elif use_subdir:
		# without --keep
		subdir = tempfile.mkdtemp(prefix=prefix + '_', dir=tmpdir)
		basename = os.path.basename(targetfilename)
		return os.path.join(subdir, basename)
	else:
		# with --keep and --keep-dir (which is tmpdir)
		basename = os.path.basename(targetfilename)
		return os.path.join(tmpdir, basename)


def compile(args, tmpdir, output, use_subdirs):
	global config

	file_args = [arg for arg in args if not arg.is_arg()]
	flag_args = [arg for arg in args if arg.is_arg()]

	stop_after_cpp  = not config.run_enabled and config.ld_disabled and config.cc_disabled and config.ppcg_disabled
	stop_after_ppcg = not config.run_enabled and config.ld_disabled and config.cc_disabled
	stop_after_cc   = not config.run_enabled and config.ld_disabled
	stop_after_ld   = not config.run_enabled

	has_extc = False
	has_pencil = False
	has_cuda = False

	if tmpdir is None:
		moreinclude = []
	else:
		moreinclude = ['-I', tmpdir]

	for filearg in file_args:
		assert not filearg.is_arg()
		if not filearg.isc and not filearg.ispencil:
			continue

		ifile = mktempwd(stop_after_cpp, output, tmpdir, 'cpp', changeext(filearg.input_file, '.i'), use_subdirs)
		cpp_file(filearg=filearg, outfile=ifile, args=flag_args)
		if stop_after_cpp:
			continue

		hostfile = mktempwd(stop_after_ppcg, output, tmpdir, 'ppcg', changeext(filearg.input_file, '_ppcg.c'), use_subdirs)
		ppcg_file(filearg=filearg, outfile=hostfile, force_embed=tmpdir is not None)
		if stop_after_ppcg:
			continue

		host_c = filearg.latest_host_source()
		if host_c is not None:
			hostofile = mktempwd(False, output, tmpdir, 'cc_host', changeext(filearg.input_file, '_host.o'), use_subdirs)
			filearg.cc_host_o = cc_file(infile=host_c, outfile=hostofile, args=file_args, isc=False, ispencil=False, moreargs=['-D__PENCIL_HOST__'] + moreinclude, ishostc=True)

		if filearg.ppcg_kernel_c is not None:
			kernelofile = mktempwd(False, output, tmpdir, 'cc_kernel', changeext(filearg.input_file, '_kernel.o'), use_subdirs)
			filearg.cc_kernel_o = cc_file(infile=filearg.ppcg_kernel_c, outfile=kernelofile,args=[], isc=filearg.isc, ispencil=filearg.ispencil, moreargs=['-D__PENCIL_KERNEL__'], iskernelc=True)

		if filearg.ppcg_kernel_cu is not None:
			kernelofile = mktempwd(False, output, tmpdir, 'nvcc_kernel', changeext(filearg.input_file, '_kernel.o'), use_subdirs)
			nvcc_cc_file(filearg=filearg,outfile=kernelofile,args=[])
			has_cuda = True

		objects = filearg.latest_objects()
		if stop_after_cc and len(objects) > 1:
			mergeofile = mktempwd(stop_after_cc, output, tmpdir, 'ld-relocate', changeext(filearg.input_file, '.o'), use_subdirs)
			ld_relocate_file(filearg=filearg,outfile=mergeofile)

	if stop_after_cc:
		return # TODO: Check there is just one input file

	if output is None and config.run_enabled:
		output = 'a.out'
	exefile = ld_file(args=args, outfile=output)

	if not config.run_enabled:
		return

	launch(os.path.abspath(exefile))


def main():
	return process(False)


if __name__ == '__main__':
	main()
